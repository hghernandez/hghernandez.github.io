---
title: "Analisis RFM para la segmentacion de clientes"
description: |
  Los modelos RFM (recency, frequency, monetary) son ampliamente utilizados en las areas de marketing para la segmentaci√≥n de sus clientes, pudiendo identificar los clientes m√°s leales, o aqu√©llos que no deber√≠a perder. En este post voy a mostrarles como implementar un modelo RFM, asi que ¬°¬°all√° vamos!!. 
preview: imagenes/cluster.jpg
author:
  - name: Hernan Hernandez
    url: https://example.com/norajones
date: 2022-08-27
output:
  distill::distill_article:
    self_contained: false
    toc: true
    toc_depth: 4
    toc_float: true
    code_folding: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  comment = "##",
  R.options = list(width = 60)
)
```

```{r include=FALSE}
##Cargo el dataset y las funciones

df <- read.csv("data/data.csv")

#cargo la funci√≥n normalize_table
source("Modulos/normalize_table.R",encoding = "UTF-8")

#Cargo la funci√≥n rfm_category
source("Modulos/rfm_category.R",encoding = "UTF-8")

#Cargo la funci√≥n segment_rfm
source("Modulos/segment_rfm.R",encoding = "UTF-8")

#Cargo las librerias

library(dplyr)
library(lubridate)
library(tidyr)
library(purrr)


```

# Introducci√≥n üöÄ

Como dec√≠amos en la preview de este post, los modelos RFM son ampliamente utilizados en las √°reas de marketing para segmentar sus carteras de clientes. Esta segmentaci√≥n se realiza a partir de un scoring (que veremos m√°s adelante), sobre tres par√°metros:

-   **recency**: identifica el tiempo transcurrido (generalmente en d√≠as), desde la √∫ltima actividad del usuario y hasta la fecha de establecida para el modelo.

-   **frequency**: refiere a con qu√© frecuencia realiza movimientos (de compra o venta) el usuario..

-   **monetary**: refiere al valor o monto de los movimientos del usuario.

El modelo **RFM** descansa sobre el siguiente principio :

> El **80%** de tu **negocio** proviene del **20%** de tus **clientes** .

En este post, iremos mostrando una serie de funciones que he creado para procesar los datos y obtener los segmentos:

-   **normalize_table:** con esta funci√≥n normalizamos los nombres del dataset para que puedan ser procesados por la funci√≥n que genera el scoring.

-   **rfm_category:** con esta funci√≥n obtenemos la tabla RFM, la cu√°l contiene los puntajes para los par√°metros (recency, frequency, monetary). Adem√°s, nos devuelve una serie de m√©tricas que utilizaremos para explorar nuestros datos.

-   **segment_rfm:** esta funci√≥n nos permite crear los segmentos a partir del scoring de la tabla anterior (tabla RFM), m√°s la definici√≥n de los *threshold.* Tambi√©n nos devuelve algunas m√©tricas que nos permiten explorar nuestros resultados.

# Exploraci√≥n de los datos üßê

Utilizaremos un **dataset** tomado de [Kaggle](https://www.kaggle.com/datasets/carrie1/ecommerce-data?resource=download) que cuenta con informaci√≥n de ventas de una tienda minorista en l√≠nea registrada y con sede en el Reino Unido. El dataset muestra las operaciones en distintos pa√≠ses lo cu√°l resulta muy atractivo a la hora de implementar un modelo RFM que contemple los datos a este nivel de agregaci√≥n.

Vamos la usar el paquete **summarytools** para obtener una tabla resumen con los valores para todas las variables.

```{r summary, results = 'asis'}
summarytools::st_options(lang = 'es')
summarytools::dfSummary(df, plain.ascii  = FALSE, 
                                           style        = "grid", 
                                           graph.magnif = 0.75, 
                                           valid.col    = FALSE,
                                           tmp.img.dir  = "/tmp")
```

En la tabla resumen puede verse que la mayor√≠a (91,4%) de las operaciones se concentran en UK,y en menos medida en Alemania y Francia. Adem√°s, podemos ver la que la fecha de la factura (InvoiceDate) es una variable texto con formato m/dd/yyyy hh:mm. Tambi√©n debe destacarse el hecho de que existen cantidades vendidas con valores menores a 0.

Considerando lo anterior transformamos la variable InvoiceDate a tipo Date (yyyy-mm-dd), excluimos cualquier valor n√∫merico menor a 0 y seleccionamos los datos para los primeros 3 pa√≠ses, es decir UK, Alemania y Francia.

Luego, agrupamos por pais, Date y CustomerID las cantidades vendidas y el monto de las mismas.

```{r}
df <- df %>%
  mutate(Date= as_date(lubridate::mdy_hm(InvoiceDate)))%>%
  group_by(Country,Date,CustomerID)%>%
  summarise(Quantity= sum(Quantity),
            Monetary= sum(UnitPrice)) %>%
  filter(Country %in% c("United Kingdom","Germany","France")) %>%
  filter_if(is.numeric, ~ .x > 0)

DT::datatable(df,filter= 'top',options = list(pageLength = 5, dom = 'tip'))
```

En la tabla podemos visualizar como nos qued√≥ conformado el dataset.

# Implementamos el modelo üí°

Esta etapa est√° compuesta por tres subetapas: a) normalizaci√≥n de la tabla, 2) creaci√≥n de los puntajes RFM, 3) creaci√≥n de los segmentos.

### Normalizaci√≥n de la tabla ‚úÇÔ∏è

Vamos a normalizar los nombres de nuestro dataset para hacerlos coincidir con los par√°metros con los que la funci√≥n *rfm_category* asigna los puntajes. Para ello usaremos la *normalize_table* que recibe el dataset con los actuales nombres de los par√°metros.

```{r}
df <- normalize_table(df = df,
                date = "Date",
                id_costumer = "CustomerID",
                cantidad = "Quantity",
                monto = "Monetary")

DT::datatable(df,filter= 'top',options = list(pageLength = 5, dom = 'tip'))
```

### 

### Creamos los puntajes RFM üõçÔ∏è

La funci√≥n *rfm_category,* admite 4 par√°metros:

-   **df**: el dataset a procesar

-   **fecha_analisis**: representa la fecha de implementaci√≥n del modelo y es √∫til para determinar los d√≠as desde la √∫ltima venta (recency).

-   **bins**: nos permite indicar el n√∫mero de segmentos en los cu√°les queremos cortar nuestra poblaci√≥n.

-   **group_by**: nos permite utilizar distintos niveles de agregaci√≥n. Como el CostumerID puede repetirse entre los pa√≠ses, con este par√°metro nos aseguramos que ese valor sea √∫nico.

    A su vez la funci√≥n nos devuelve:

-   **resultado_rfm**: una tabla que contiene el scoring

-   **heatmap**: un gr√°fico que muestra el promedio del monto para las combinaciones de recency y de frequency.

-   **threshold:** una tabla con los umbrales para recency, frequency y monetary.

    Sin m√°s pre√°mbulos, miremos el resultado de la funci√≥n.

```{r}
tabla_rfm <- df %>%
  mutate(email= "cliente@rfm.com")%>%
  split(.$Country) %>%
  map(~ rfm_category(df = .,
                     fecha_analisis = '2011-12-09',
                     bins = 4,
                     group_by = "Country"))
```

```{r xaringan-panelset, echo=FALSE}
xaringanExtra::use_panelset()

```

::: panelset
```{r results="asis"}
for(i in 1:length(tabla_rfm)){
  cat("::: {.panel}\n")             
  cat("##", unique(tabla_rfm[[i]]$resultado_rfm$Country) , "{.panel-name}\n") 
  print(tabla_rfm[[i]]$heatmap)
  cat("\n")
  print(kableExtra::kbl(tabla_rfm[[i]]$threshold,
                      format.args = list(decimal.mark = ',', big.mark = "."), col.names = rep(c("lower","upper"),3),
                      caption = paste0("Puntos de corte scoring. ",unique(tabla_rfm[[i]]$resultado_rfm$Country),"."))%>%
        kableExtra::add_header_above(c("Recency" = 2, "Frequency" = 2, "Monetary"= 2),color = "#191C3C", bold = T,align = "center") %>%   
kableExtra::kable_paper())
  cat("\n") 
  cat(":::\n")
}
```
:::

Aqu√≠ podemos ver los primeros 10 registros de la tabla RFM para UK.

```{r}
DT::datatable(tabla_rfm[[3]]$resultado_rfm %>% head(10),filter= 'top',options = list(pageLength = 5, dom = 'tip'))
```

#### ¬øC√≥mo se asignan los puntajes? ¬øQue representan esos valores? ü§î

C√≥mo se puede observar en la tabla anterior, al dataset se le han a√±adido 3 columnas (recency_cut, frequency_cut y monetary_cut), con valores de 1 a 4 [^1](seg√∫n la cantidad de cortes o bins elegidos podr√≠a ser 5), que deben interpretarse del siguiente modo:

[^1]: la cantidad de cortes seleccionados divide a la poblaci√≥n en partes iguales. Si seleccionamos 4 cortes, dividimos a la poblaci√≥n en cuartiles cada uno de los cu√°les representa el 25%. Si decidi√©ramos utilizar 5 cortes, dividir√≠amos la poblaci√≥n en quintiles, representando cada uno un 20%.

**recency**: la puntuaci√≥n se genera asignando a los clientes con las fechas de ventas m√°s recientes la m√°xima puntuaci√≥n (4 en este caso), y aquellos con fechas de ventas m√°s distante reciben una clasificaci√≥n de actualidad de 1.

**frequency**: a los usuarios con mayor cantidad de unidades vendidas se les asigna una puntuaci√≥n m√°s alta (4) y a los de menor cantidad una puntuaci√≥n de 1.

**monetary**: se asigna sobre la base del monto total de las ventas al usuario en el per√≠odo considerado para el an√°lisis. A los clientes con mayores montos de venta se les asigna una puntuaci√≥n m√°s alta, mientras que a los que tienen montos de venta m√°s bajos se les asigna una puntuaci√≥n de 1.

Los *heatmap*, confirman -aunque en menor medida para Francia- que los montos promedios m√°s altos povienen que los usuarios con mayor cantidad de bienes vendidos y con recientes operaciones.

Cuando se implement√≥ el modelo con bins= 5, para Francia y Alemania se obtuvo un gr√°fico inconsistente (no completo todos sus casilleros), por lo que se decidi√≥ utilizar 4 cortes.

### Creamos los segmentos ‚úèÔ∏è

Para la creaci√≥n de los segmentos utilizaremos la funci√≥n *segment_rfm*, a la cu√°l debemos pasarle 3 grupos de par√°metros:

-   **tabla_rfm:** es la tabla resultante de la funci√≥n anterior y contiene cada uno de nuestros costumer con un puntaje de recency, frequency y monetary asignado.

-   **nombres_segmentos:** es un vector de datos con la cantidad de nombres comos segmentos queramos utilizar. En nuestro caso utilizaremos 7 segmentos (incluyendo los sin clasificar) para hacerlo m√°s comprensible.

-   **umbrales de los segmentos**: llevan los nombres recency_lower, recency_upper, frequency_lower, frequency_upper, monetary_lower, monetary_upper y son vectores que contienen los umbrales con los cu√°les agrupamos en segmentos los scoring rfm.

Esta funci√≥n nos retorna:

**tabla_rfm**: que contiene cada uno de nuestros costumer segmentados

**bar_chart**: gr√°fico de barras que contabiliza los costumer seg√∫n el puntaje de recency, frequency y monetary. Representa una estrategia visual para observar la composici√≥n de nuestros clientes.

**Composicion_segmento**: muestra la frecuencia absoluta y relativa de los costumer seg√∫n los segmentos.

**bar_chart_seg**: gr√°fico de barras con la composici√≥n por segmentos.

**impact_segment**:contabiliza en t√©rminos absolutos y relativos el impacto que tienen los segmentos sobre las ventas y el monto en el pa√≠s.

#### Comenzamos por definir los segmentos y los umbrales üìù

Como se mencion√≥ anteriormente trabajaremos con los siguientes segmentos:

-   **Champions**: es el segmento que re√∫ne el m√°ximo puntaje en los tres par√°metros. Para las ventas en UK este segmento concentra el 43% de las mismas y el 40% del monto facturado.

-   **Loyalist**: son los clientes que tienen el m√°ximo puntaje en la cantidad de productos comprados. Representan el segundo segmento en t√©rminos de monto facturado.

-   **Big Spenders**: este segmento tiene el m√°ximo puntaje en los montos de compras. Si bien en t√©rmino de cantidad adquirida no son influyente, respresentan el tercer segmento en monto facturado.

-   **Promising:** este segmento muestra puntajes de RFM por encima del resto, pero por debajo de los **champions**. Est√°n t√≠midos pero son sensibles de estimular.

-   **New costumer:** tienen alto puntaje en recency, es decir han realizado compras recientes aunque no por mucha cantidad ni de montos altos. Debemos estimularlos.

-   **Hibernating:** muestran los puntajes m√°s bajos en las tres categor√≠as.

Asignamos los umbrales

-   **recency_lower** : 4,1,1,2,4,1

-   **recency_upper**: 4,4,4,4,4,1

-   **frequency_lower**: 4,4,1,2,1,1

-   **frequency_upper**: 4,4,4,4,4,1

-   **monetary_lower**: 4,1,4,2,1,1

-   **monetary_upper**: 4,4,4,4,4,1

```{r}
nombres_segmentos <- c("Champions","Loyalist","Big Spenders",
                       "Promising","New Customers","Hibernating")
recency_lower <-   c(4,1,1,2,4,1)
recency_upper <-   c(4,4,4,4,4,1)
frequency_lower <- c(4,4,1,2,1,1)
frequency_upper <- c(4,4,4,4,4,1)
monetary_lower <-  c(4,1,4,2,1,1)
monetary_upper <-  c(4,4,4,4,4,1)

rfm <- list()

for(i in 1:length(tabla_rfm)){
  rfm[[i]] <- segment_rfm(tabla_rfm = tabla_rfm[[i]],
                          nombres_segmentos = nombres_segmentos,
                          recency_lower,
                          recency_upper,
                          frequency_lower,
                          frequency_upper,
                          monetary_lower,
                          monetary_upper
  )
}
```

::: panelset
```{r segmentos, results='asis'}
for(i in 1:length(rfm)){

  cat("::: {.panel}\n")             

  cat("###", unique(rfm[[i]]$tabla_rfm$Country), "{.panel-name}\n")
cat("\n")
cat("#### Distribuci√≥n de los clientes seg√∫n el scoring (RFM")
print(rfm[[i]]$bar_chart)
cat("\n")
cat("#### Composici√≥n de los segmentos")
cat("\n")

  print(kableExtra::kbl(rfm[[i]]$Composicion_segmento,

        format.args = list(decimal.mark = ',', big.mark = ".")) %>%

     kableExtra::kable_paper())

 cat("\n")
 cat("#### Gr√°fico composici√≥n de los segmentos")
 print(rfm[[i]]$bar_chart_seg)
 cat("\n")

 cat("#### Impacto de los segmentos en las Ventas y el Monto")

  cat("\n")

  print(kableExtra::kbl(rfm[[i]]$impact_segment,
        col.names = c("Segmentos","Ventas","%","Monto","%"),
                      
        format.args = list(decimal.mark = ',', big.mark = ".")) %>%
        
        kableExtra::kable_paper())

  cat("\n")

  cat(":::\n")

}
```
:::

#### ¬øQue podemos decir de los segmentos? üîà

üëâüèº Los patrones y tendencias son m√°s f√°cil de obervar en UK en raz√≥n de una mayor cantidad de observaciones. El *bar_chart* que combina los scoring de los tres par√°metros muestra que los clientes que realizan compras de mayor valor adem√°s tienen altos puntajes de recency y de frequency (esquina superior derecha). En el opuesto, los que tienen menores puntajes de monetary coincide con los menores tambi√©n de recency y frequency. Esto se da tambi√©n en los clientes de Alemania y Francia pero con menos nitidez.

üëâüèºUn punto interesante es el segmento *Usuals*, que representa a los clientes no clasificados en los umbrales y que es el principal segmento de UK y Alemania. El porcentaje de este segmento est√° directamente vinculado a los objetivos de la compa√±√≠a en relaci√≥n a las pol√≠ticas de fidelizaci√≥n y en t√©rminos estad√≠sticos a la *sensibilidad y* *especificidad* con la que creamos los umbrales. En nuestro caso. si tom√°ramos umbrales m√°s amplios lograr√≠amos diminuir ese conjunto de cliente (usuals) pero corremos el riesgo de por ejemplo clasificar como Champions clientes que no lo son o viceversa, como Hibernating a clientes que est√°n activos. Tambi√©n podr√≠amos generar nuevos segmentos para incluir este grupo de clientes. Esta es una discusi√≥n por dem√°s interesante que requiere de un dialogo fluido entre la estad√≠stica y el marketing.

üëâüèºSalvo para Francia, los segmentos Champions y Loyalist concentran la mayor parte de las ventas y la facturaci√≥n (Monto). Los Big Spenders en estos pa√≠ses representan el tercer segmento en cuanto a facturaci√≥n. Los Promising son una oportunidad para el negocio ya que son sensibles a promociones y estrategias de marketing.

# Comentarios finales üòâ

üî¶Son varias cosas las que me surgen para este apartado final pero voy a abocarme s√≥lo a algunas de ellas. Por un lado, la oportunidad que representan los an√°lisis RFM para el di√°logo entre la estad√≠stica, los datos y el apoyo a los *decision makers*.

üî¶Por otro lado,en este post he mostrado 3 funciones desarrolladas √≠ntegramente en R que pueden adaptarse para su uso en distintos escenarios y que cuentan con la posibilidad de ajustar los par√°metros centrales para lograr robustez en los resultados.

Sin dudas hay mucho camino por recorrer a√∫n en el mundo de los datos., as√≠ que sigamos viajando‚úàÔ∏è.
